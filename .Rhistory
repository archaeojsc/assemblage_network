plot(sigmoid(sort(prov_sims$ssoc)), type = "h")
#| label: code-bpg
#| echo: false
#| message: false
require(tidyverse)
require(igraph)
require(ggraph)
# Import data from file ---------------------------------------------------
dat <- read_csv("Catalog_SiteA.csv",
col_select = c(LEVEL_ID, CODE))
# Create un-weighted bipartite graph --------------------------------------
g_assemblages_bpg <-
graph_from_data_frame(unique.data.frame(select(dat, LEVEL_ID, CODE)),
directed = FALSE)
V(g_assemblages_bpg)$type <-
bipartite_mapping(g_assemblages_bpg)$type
#| label: fig-bipartite-graph
#| fig-cap: "Bipartite network of Provenience and Artifact Type."
#| fig-alt: "Bipartite graph plot of proveniences and artifact types."
#| echo: false
#| message: false
#| warning: false
g_assemblages_bpg_layout <-
g_assemblages_bpg %>% layout_as_bipartite()
g_assemblages_bpg %>%
ggraph(layout = g_assemblages_bpg_layout) +
geom_edge_link(edge_color = "gray", edge_alpha = 0.25) +
geom_node_point(aes(color = type)) +
scale_color_manual(
values = c("green", "blue"),
name = "Node Type",
breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")
) +
ggtitle("Bipartite network of Provenience and Artifact Type")
#| label: code-reestablish-environment
#| echo: false
#| message: false
#| warning: false
# Create incidence matrix from bipartite graph -----------------------------
g_assemblages_bpg_inc <- as_incidence_matrix(g_assemblages_bpg)
# Project one-mode graphs, Szymkiewicz-Simpson -----------------------------
overlap_coef_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Find the smaller of each pair of sets by taking the matrix outer minimum
min_set_size_mat <- outer(col_sum, col_sum, FUN = pmin)
# Szymkiewicz-Simpson overlap coefficient is the pairwise intersection of two
# sets divided by the size of the smaller set
res <- bin_intersect_mat / min_set_size_mat
# Set diagonal to identity
diag(res) <- 1L
# Assign input column names to rows and columns of return matrix
dimnames(res) <- list(colnames(x), colnames(x))
return(res)
}
## Project provenience -----------------------------------------------------
prov_adj_ssoc <- overlap_coef_bin(t(g_assemblages_bpg_inc))
prov_ssoc_vals <-
prov_adj_ssoc[lower.tri(prov_adj_ssoc, diag = FALSE)]
## Project artifact types --------------------------------------------------
artifact_adj_ssoc <- overlap_coef_bin(g_assemblages_bpg_inc)
artifact_ssoc_vals <-
artifact_adj_ssoc[lower.tri(artifact_adj_ssoc, diag = FALSE)]
# Project one-mode graphs, Sorenson-Dice -----------------------------------
soren_dice_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums, to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(col_sum, col_sum, FUN = "+")
# Sorenson-Dice index is twice the size of the intersection divided by the
# sum of the size for each set
res <- (2 * bin_intersect_mat) / set_size_sum_mat
# Set diagonal to identity
diag(res) <- 1L
# Assign input column names to rows and columns of return matrix
dimnames(res) <- list(colnames(x), colnames(x))
return(res)
}
## Project provenience -----------------------------------------------------
prov_adj_sd <- soren_dice_sim_bin(t(g_assemblages_bpg_inc))
prov_sd_vals <-
prov_adj_sd[lower.tri(prov_adj_sd, diag = FALSE)]
## Project artifact types --------------------------------------------------
artifact_adj_sd <- soren_dice_sim_bin(g_assemblages_bpg_inc)
artifact_sd_vals <-
artifact_adj_sd[lower.tri(artifact_adj_sd, diag = FALSE)]
# Project one-mode graphs, Jaccard ----------------------------------------
jaccard_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
x_col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(x_col_sum, x_col_sum, FUN = "+")
# Jaccard index is intersection of set sizes over the size of the union of
# sets
res <- bin_intersect_mat / (set_size_sum_mat - bin_intersect_mat)
# Set diagonal to identity
diag(res) <- 1L
# Assign input column names to rows and columns of return matrix
dimnames(res) <- list(colnames(x), colnames(x))
return(res)
}
## Project provenience -----------------------------------------------------
prov_adj_jacc <- jaccard_sim_bin(t(g_assemblages_bpg_inc))
prov_jacc_vals <-
prov_adj_jacc[lower.tri(prov_adj_jacc, diag = FALSE)]
## Project artifact types --------------------------------------------------
artifact_adj_jacc <- jaccard_sim_bin(g_assemblages_bpg_inc)
artifact_jacc_vals <-
artifact_adj_jacc[lower.tri(artifact_adj_jacc, diag = FALSE)]
# Comparing similarity measures -------------------------------------------
prov_sims <-
data.frame(ssoc = prov_ssoc_vals,
jacc = prov_jacc_vals,
sd = prov_sd_vals)
artifact_sims <-
data.frame(ssoc = artifact_ssoc_vals,
jacc = artifact_jacc_vals,
sd = artifact_sd_vals)
#| label: fig-sim-prov
#| fig-cap: "Similarity measures for proveniences."
#| fig-alt: "Similarity measures for proveniences."
#| echo: false
#| message: false
#| warning: false
# Plot densities by similarity measure
prov_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "green",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free") +
ggtitle("Similarity Measures for Proveniences")
#| label: fig-sim-artifact
#| fig-cap: "Similarity measures for artifact types."
#| fig-alt: "Similarity measures for artifact types."
#| echo: false
#| message: false
#| warning: false
# Plot densities by similarity measure
artifact_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free") +
ggtitle("Similarity Measures for Artifact Types")
#| label: fig-power-law
#| fig-cap: "Power-law distribution for different values of gamma."
#| fig-alt: "Power-law distribution for different values of gamma."
#| echo: false
#| message: false
#| warning: false
powerlaw_pdf <- function(x, gamma = 1) {
density <- x ^ (-gamma)
return(density)
}
ggplot(data.frame(x = c(1, 251)), aes(x = x)) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 2), aes(color = "2")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 3), aes(color = "3")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 4), aes(color = "4")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 5), aes(color = "5")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 6), aes(color = "6")) +
labs(color = "Gamma") +
ylab("P(x)")
#| label: fig-power-law-log
#| fig-cap: "Log-scale power-law distribution for different values of gamma."
#| fig-alt: "Log-scale power-law distribution for different values of gamma."
#| echo: false
#| message: false
#| warning: false
ggplot(data.frame(x = c(1, 251)), aes(x = x)) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 2), aes(color = "2")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 3), aes(color = "3")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 4), aes(color = "4")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 5), aes(color = "5")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 6), aes(color = "6")) +
scale_y_continuous(trans="log10") +
labs(color = "Gamma") +
ylab("log P(x)")
signum_adj <- function(x, tau) {
return(ifelse(x < tau, 0, 1))
}
test <- signum_adj(artifact_adj_jacc, quantile(artifact_sims$jacc, probs = 0.9))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = FALSE, diag=FASLE)
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FASLE)
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g)
library(igraph)
library(ggraph)
test_g %>% ggraph(layout = "fr")+geom_edge_link()+geom_node_point(
)
test_g %>% ggraph(layout = "fr")+geom_edge_link()+geom_node_point(color="green", size = 2)
require(tidyverse)
require(igraph)
require(ggraph)
dat <- read_csv("Catalog_SiteA.csv",
col_select = c(LEVEL_ID, CODE)
)
#| fig-width: 8
#| fig-cap: "Bipartite graph of artifact-provenience connections."
g_assemblages_bpg <-
graph_from_data_frame(unique.data.frame(dat),
directed = FALSE
)
V(g_assemblages_bpg)$type <-
bipartite_mapping(g_assemblages_bpg)$type
g_assemblages_bpg %>%
ggraph(layout = "bipartite") +
geom_edge_link(color = "gray", alpha = 0.25) +
geom_node_point(aes(color = type), size = 2) +
scale_color_manual(
values = c("green", "blue"),
name = "Node Type",
breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")
)
g_assemblages_bpg
assemblages_inc <- as_incidence_matrix(g_assemblages_bpg)
assemblages_inc[1:5, 1:15]
assemblage_projections <-
bipartite_projection(g_assemblages_bpg, multiplicity = TRUE)
assemblage_projections
g_assemblage_prov <- assemblage_projections$proj1
g_assemblage_artifact <- assemblage_projections$proj2
g_assemblage_prov <- assemblage_projections$proj1
g_assemblage_artifact <- assemblage_projections$proj2
#| fig-cap: "Projected graph of provenience."
g_assemblage_prov %>%
ggraph(layout = "fr") +
geom_edge_link(aes(alpha = weight)) +
geom_node_point(color = "green", size = 2)
test_g %>% ggraph(layout = "fr")+geom_edge_link()+geom_node_point(aes(size = degree, alpha = degree), colour = "black")
plot(density(degree(test_g)))
test <- signum_adj(artifact_adj_jacc, quantile(artifact_sims$jacc, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(density(degree(test_g)))
test <- signum_adj(artifact_adj_ssoc, quantile(artifact_sims$ssoc, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(density(degree(test_g)))
degree_distribution(test_g)
plot(degree_distribution(test_g))
plot(degree_distribution(test_g, cumulative = TRUE))
transitivity(test_g)
plot(degree_distribution(test_g, cumulative = FALSE, mode=c("total")))
hist(degree(test_g), breaks=1:vcount(test_g)-1, main="Histogram of node degree")
plot(x=0:max(degree(test_g)), y=1- degree_distribution(test_g, cumulative = T, mode="all"))
plot(test_g, vertex.size=hub_score(test_g)$vector)
plot(test_g, vertex.size=hub_score(test_g)$vector*50)
plot(density(test_g))
plot(density(degree(test_g)))
plot(g_assemblages_bpg, layout = layout_with_graphopt)
plot(g_assemblages_bpg, layout = layout_with_graphopt, size = 2)
#| label: code-bpg
#| echo: false
#| message: false
require(tidyverse)
require(igraph)
require(ggraph)
# Import data from file ---------------------------------------------------
dat <- read_csv("Catalog_SiteA.csv",
col_select = c(LEVEL_ID, CODE))
# Create un-weighted bipartite graph --------------------------------------
g_assemblages_bpg <-
graph_from_data_frame(unique.data.frame(select(dat, LEVEL_ID, CODE)),
directed = FALSE)
V(g_assemblages_bpg)$type <-
bipartite_mapping(g_assemblages_bpg)$type
#| label: fig-bipartite-graph
#| fig-cap: "Bipartite network of Provenience and Artifact Type."
#| fig-alt: "Bipartite graph plot of proveniences and artifact types."
#| echo: false
#| message: false
#| warning: false
g_assemblages_bpg_layout <-
g_assemblages_bpg %>% layout_as_bipartite()
g_assemblages_bpg %>%
ggraph(layout = g_assemblages_bpg_layout) +
geom_edge_link(edge_color = "gray", edge_alpha = 0.25) +
geom_node_point(aes(color = type)) +
scale_color_manual(
values = c("green", "blue"),
name = "Node Type",
breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")
) +
ggtitle("Bipartite network of Provenience and Artifact Type")
#| label: code-reestablish-environment
#| echo: false
#| message: false
#| warning: false
# Create incidence matrix from bipartite graph -----------------------------
g_assemblages_bpg_inc <- as_incidence_matrix(g_assemblages_bpg)
# Project one-mode graphs, Szymkiewicz-Simpson -----------------------------
overlap_coef_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Find the smaller of each pair of sets by taking the matrix outer minimum
min_set_size_mat <- outer(col_sum, col_sum, FUN = pmin)
# Szymkiewicz-Simpson overlap coefficient is the pairwise intersection of two
# sets divided by the size of the smaller set
res <- bin_intersect_mat / min_set_size_mat
# Set diagonal to identity
diag(res) <- 1L
# Assign input column names to rows and columns of return matrix
dimnames(res) <- list(colnames(x), colnames(x))
return(res)
}
## Project provenience -----------------------------------------------------
prov_adj_ssoc <- overlap_coef_bin(t(g_assemblages_bpg_inc))
prov_ssoc_vals <-
prov_adj_ssoc[lower.tri(prov_adj_ssoc, diag = FALSE)]
## Project artifact types --------------------------------------------------
artifact_adj_ssoc <- overlap_coef_bin(g_assemblages_bpg_inc)
artifact_ssoc_vals <-
artifact_adj_ssoc[lower.tri(artifact_adj_ssoc, diag = FALSE)]
# Project one-mode graphs, Sorenson-Dice -----------------------------------
soren_dice_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums, to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(col_sum, col_sum, FUN = "+")
# Sorenson-Dice index is twice the size of the intersection divided by the
# sum of the size for each set
res <- (2 * bin_intersect_mat) / set_size_sum_mat
# Set diagonal to identity
diag(res) <- 1L
# Assign input column names to rows and columns of return matrix
dimnames(res) <- list(colnames(x), colnames(x))
return(res)
}
## Project provenience -----------------------------------------------------
prov_adj_sd <- soren_dice_sim_bin(t(g_assemblages_bpg_inc))
prov_sd_vals <-
prov_adj_sd[lower.tri(prov_adj_sd, diag = FALSE)]
## Project artifact types --------------------------------------------------
artifact_adj_sd <- soren_dice_sim_bin(g_assemblages_bpg_inc)
artifact_sd_vals <-
artifact_adj_sd[lower.tri(artifact_adj_sd, diag = FALSE)]
# Project one-mode graphs, Jaccard ----------------------------------------
jaccard_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
x_col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(x_col_sum, x_col_sum, FUN = "+")
# Jaccard index is intersection of set sizes over the size of the union of
# sets
res <- bin_intersect_mat / (set_size_sum_mat - bin_intersect_mat)
# Set diagonal to identity
diag(res) <- 1L
# Assign input column names to rows and columns of return matrix
dimnames(res) <- list(colnames(x), colnames(x))
return(res)
}
## Project provenience -----------------------------------------------------
prov_adj_jacc <- jaccard_sim_bin(t(g_assemblages_bpg_inc))
prov_jacc_vals <-
prov_adj_jacc[lower.tri(prov_adj_jacc, diag = FALSE)]
## Project artifact types --------------------------------------------------
artifact_adj_jacc <- jaccard_sim_bin(g_assemblages_bpg_inc)
artifact_jacc_vals <-
artifact_adj_jacc[lower.tri(artifact_adj_jacc, diag = FALSE)]
# Comparing similarity measures -------------------------------------------
prov_sims <-
data.frame(ssoc = prov_ssoc_vals,
jacc = prov_jacc_vals,
sd = prov_sd_vals)
artifact_sims <-
data.frame(ssoc = artifact_ssoc_vals,
jacc = artifact_jacc_vals,
sd = artifact_sd_vals)
#| label: fig-sim-prov
#| fig-cap: "Similarity measures for proveniences."
#| fig-alt: "Similarity measures for proveniences."
#| echo: false
#| message: false
#| warning: false
# Plot densities by similarity measure
prov_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "green",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free") +
ggtitle("Similarity Measures for Proveniences")
#| label: fig-sim-artifact
#| fig-cap: "Similarity measures for artifact types."
#| fig-alt: "Similarity measures for artifact types."
#| echo: false
#| message: false
#| warning: false
# Plot densities by similarity measure
artifact_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free") +
ggtitle("Similarity Measures for Artifact Types")
#| label: fig-power-law
#| fig-cap: "Power-law distribution for different values of gamma."
#| fig-alt: "Power-law distribution for different values of gamma."
#| echo: false
#| message: false
#| warning: false
powerlaw_pdf <- function(x, gamma = 1) {
density <- x ^ (-gamma)
return(density)
}
ggplot(data.frame(x = c(1, 251)), aes(x = x)) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 2), aes(color = "2")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 3), aes(color = "3")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 4), aes(color = "4")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 5), aes(color = "5")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 6), aes(color = "6")) +
labs(color = "Gamma") +
ylab("P(k)") + xlab("k")
#| label: fig-power-law-log
#| fig-cap: "Log-scale power-law distribution for different values of gamma."
#| fig-alt: "Log-scale power-law distribution for different values of gamma."
#| echo: false
#| message: false
#| warning: false
ggplot(data.frame(x = c(1, 251)), aes(x = x)) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 2), aes(color = "2")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 3), aes(color = "3")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 4), aes(color = "4")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 5), aes(color = "5")) +
stat_function(fun = powerlaw_pdf, args = list(gamma = 6), aes(color = "6")) +
scale_y_continuous(trans = "log10") +
labs(color = "Gamma") +
ylab("log P(k)") + xlab("k")
hard_threshold_adj <- function(x, tau) {
return(ifelse(x < tau, 0, 1))
}
degree_distribution(test_g)
degree_distribution(test_g, loops=T)
sum(degree_distribution(test_g, loops=T))
hist(degree_distribution(test_g, loops=T))
hist(degree_distribution(test_g, cumulative = T))
plot(degree_distribution(test_g, cumulative = T))
plot(degree_distribution(test_g, cumulative = T), log = "xy")
plot(degree_distribution(test_g, cumulative = T), log = "xy", type = "h")
plot(degree_distribution(test_g, cumulative = T), log = "xy", type = "l", col="red")
log(0)
plot(degree_distribution(test_g, cumulative = T)^6, log = "xy", type = "l", col="red")
plot(degree_distribution(test_g, cumulative = T), log = "xy", type = "l", col="red")
test <- signum_adj(artifact_adj_jacc, quantile(artifact_sims$jacc, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(degree_distribution(test_g, cumulative = T), log = "xy", type = "l", col="red")
test_g
test <- signum_adj(artifact_adj_sd, quantile(artifact_sims$sd, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
test_g
test <- signum_adj(artifact_adj_ssoc, quantile(artifact_sims$ssoc, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
test_g
plot(degree_distribution(test_g, cumulative = T), log = "xy", type = "l", col="red")
plot(test_g, layout=layout_in_circle)
plot(test_g, layout=layout_in_circle, size=1)
plot(test_g, layout=layout_in_circle, vertex.size=1)
test <- signum_adj(artifact_adj_jacc, quantile(artifact_sims$jacc, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g, layout=layout_in_circle, vertex.size=1)
plot(test_g, layout=layout.graphopt, vertex.size=1)
plot(test_g, layout=layout.graphopt, vertex.size=2, label=NA)
plot(test_g, layout=layout.graphopt, vertex.size=2, vertex.label=NA)
plot(test_g, layout="nicely", vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_nicely, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_with_kk, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_with_gem, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
test <- signum_adj(artifact_adj_jacc, quantile(artifact_sims$jacc, probs = 0.99))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
test <- signum_adj(artifact_adj_ssoc, quantile(artifact_sims$ssoc, probs = 0.99))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
test <- signum_adj(artifact_adj_sd, quantile(artifact_sims$sd, probs = 0.99))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
test <- signum_adj(artifact_adj_sd, quantile(artifact_sims$sd, probs = 0.95))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_with_kk, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_graphopt, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_nicely, vertex.size=2, vertex.label=NA)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
test <- signum_adj(artifact_adj_sd, quantile(artifact_sims$sd, probs = 0.99))
test_g <- igraph::graph_from_adjacency_matrix(test, mode = "undirected", weighted = NULL, diag=FALSE)
plot(test_g, layout=layout_with_fr, vertex.size=2, vertex.label=NA)
plot(degree_distribution(test_g, cumulative = T), log = "xy", type = "l", col="red")
