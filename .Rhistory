breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")) +
ggtitle("Bipartite network of Provenience and Artifact Type")
g_assemblages_bpg_inc <- as_incidence_matrix(g_assemblages_bpg)
# View the first few rows and columns
g_assemblages_bpg_inc[1:5, 1:15]
4/7
install.packages(c("cli", "cpp11", "crayon", "curl", "data.table", "digest", "evaluate", "ggforce", "ggraph", "graphlayouts", "igraph", "isoband", "jsonlite", "lifecycle", "openssl", "polyclip", "purrr", "RcppArmadillo", "readr", "rlang", "rmarkdown", "sys", "tidyselect", "tinytex", "vctrs", "vroom", "xfun", "yaml"))
install.packages(c("cli", "cpp11", "crayon", "curl", "data.table", "digest", "evaluate", "ggforce", "ggraph", "graphlayouts", "igraph", "isoband", "jsonlite", "lifecycle", "openssl", "polyclip", "purrr", "RcppArmadillo", "readr", "rlang", "rmarkdown", "sys", "tidyselect", "tinytex", "vctrs", "vroom", "xfun", "yaml"))
require(tidyverse)
require(igraph)
require(ggraph)
# Read in edgelist into data frame
dat <- read_csv("Catalog_SiteA.csv",
col_select = c(LEVEL_ID, CODE))
# Create graph
g_assemblages_bpg <-
graph_from_data_frame(unique.data.frame(dat),
directed = FALSE)
# Assign bipartite node types
V(g_assemblages_bpg)$type <-
bipartite_mapping(g_assemblages_bpg)$type
#| fig-width: 8
#| fig-cap: "Bipartite graph of artifact-provenience connections."
# Plot bipartite graph
g_assemblages_bpg %>%
ggraph(layout = "bipartite") +
geom_edge_link(color = "gray", alpha = 0.25) +
geom_node_point(aes(color = type), size = 2) +
scale_color_manual(
values = c("green", "blue"),
name = "Node Type",
breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")) +
ggtitle("Bipartite network of Provenience and Artifact Type")
g_assemblages_bpg_inc <- as_incidence_matrix(g_assemblages_bpg)
# View the first few rows and columns
g_assemblages_bpg_inc[1:5, 1:15]
# Szymkiewicz-Simpson overlap coefficient for binary incidence matrices
overlap_coef_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Find the smaller of each pair of sets by taking the matrix outer minimum
min_set_size_mat <- outer(col_sum, col_sum, FUN = pmin)
# Szymkiewicz-Simpson overlap coefficient is the pairwise intersection of two
# sets divided by the size of the smaller set
ssoc <- bin_intersect_mat / min_set_size_mat
# Set diagonal to identity
diag(ssoc) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(ssoc) <- list(colnames(x), colnames(x))
return(ssoc)
}
# Jaccard/Tanimoto similarity index for binary incidence matrices
jaccard_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
x_col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(x_col_sum, x_col_sum, FUN = "+")
# Jaccard index is intersection of set sizes over the size of the union of
# sets
jacc <- bin_intersect_mat / (set_size_sum_mat - bin_intersect_mat)
# Set diagonal to identity
diag(jacc) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(jacc) <- list(colnames(x), colnames(x))
return(jacc)
}
# Sørensen–Dice Coefficient for binary incidence matrices
soren_dice_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums, to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(col_sum, col_sum, FUN = "+")
# Sorenson-Dice index is twice the size of the intersection divided by the
# sum of the size for each set
sd <- (2 * bin_intersect_mat) / set_size_sum_mat
# Set diagonal to identity
diag(sd) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(sd) <- list(colnames(x), colnames(x))
return(sd)
}
#| fig-cap: "Sample size distribution."
require(gridExtra)
grid.arrange(
ggplot(
data = data.frame(x = rowSums(g_assemblages_bpg_inc)),
aes(x = x)) +
geom_histogram(color = "gray", fill = "green", bins = 20) +
ggtitle("Artifact Types per Provenience"),
ggplot(
data = data.frame(x = colSums(g_assemblages_bpg_inc)),
aes(x = x)) +
geom_histogram(color = "gray", fill = "blue", bins = 20) +
ggtitle("Occurence per Artifact Type"),
ncol = 2
)
# Overlap coefficient, provenience
prov_adj_ssoc <- overlap_coef_bin(t(g_assemblages_bpg_inc))
prov_ssoc_vals <-
prov_adj_ssoc[lower.tri(prov_adj_ssoc, diag = FALSE)]
# Jaccard, provenience
prov_adj_jacc <- jaccard_sim_bin(t(g_assemblages_bpg_inc))
prov_jacc_vals <-
prov_adj_jacc[lower.tri(prov_adj_jacc, diag = FALSE)]
# Sorenson-Dice
prov_adj_sd <- soren_dice_sim_bin(t(g_assemblages_bpg_inc))
prov_sd_vals <-
prov_adj_sd[lower.tri(prov_adj_sd, diag = FALSE)]
# Make data frame to compare
prov_sims <-
data.frame(ssoc = prov_ssoc_vals,
jacc = prov_jacc_vals,
sd = prov_sd_vals)
# Plot densities by similarity measure
prov_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "green",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
# Overlap coefficient, artifact types
artifact_adj_ssoc <- overlap_coef_bin(g_assemblages_bpg_inc)
artifact_ssoc_vals <-
artifact_adj_ssoc[lower.tri(artifact_adj_ssoc, diag = FALSE)]
# Jaccard, artifact types
artifact_adj_jacc <- jaccard_sim_bin(g_assemblages_bpg_inc)
artifact_jacc_vals <-
artifact_adj_jacc[lower.tri(artifact_adj_jacc, diag = FALSE)]
#Sorenson-Dice, artifact types
artifact_adj_sd <- soren_dice_sim_bin(g_assemblages_bpg_inc)
artifact_sd_vals <-
artifact_adj_sd[lower.tri(artifact_adj_sd, diag = FALSE)]
# Make data frame to compare
artifact_sims <-
data.frame(ssoc = artifact_ssoc_vals,
jacc = artifact_jacc_vals,
sd = artifact_sd_vals)
# Plot densities by similarity measure
artifact_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
# Plot densities by similarity measure
artifact_sims %>% stack() %>%
filter(values > 0) %>% # Exclude zeroes
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
setwd("~/Documents/Python Projects/archaeojsc.github.io/docs/assemblage_network")
library(DBI)
library(odbc)
library(dplyr)
library(dbplyr)
dbFileName <- "1BOW.00.101 Prattsville (10-2014).accdb"
connect_to_access_dbi <- function(db_file_path)  {
require(DBI)
# make sure that the file exists before attempting to connect
if (!file.exists(db_file_path)) {
stop("DB file does not exist at ", db_file_path)
}
# Assemble connection strings
dbq_string <- paste0("DBQ=", db_file_path)
driver_string <-
"Driver={Microsoft Access Driver (*.mdb, *.accdb)};"
db_connect_string <- paste0(driver_string, dbq_string)
myconn <- dbConnect(odbc::odbc(),
.connection_string = db_connect_string)
return(myconn)
}
test <- connect_to_access_dbi(dbFileName)
odbc::odbcListDrivers()
odbc::odbcListDrivers()
test <- DBI::dbConnect(odbc::odbc(), DBQ=dbFileName)
odbc::odbcListDrivers()
library(DBI)
library(odbc)
odbc::odbcListDrivers()
library(DBI)
library(odbc)
library(dplyr)
library(dbplyr)
odbc::odbcListDrivers()
library(DBI)
library(odbc)
library(dplyr)
library(dbplyr)
odbcListDrivers()
install.packages(c("ade4", "bit", "bslib", "callr", "data.table", "digest", "evaluate", "ggplot2", "ggrepel", "graphlayouts", "htmltools", "jsonlite", "knitr", "lubridate", "markdown", "modelr", "openssl", "processx", "ps", "RcppArmadillo", "RcppEigen", "rmarkdown", "sass", "sp", "stringr", "vctrs", "xfun"))
require(tidyverse)
require(igraph)
require(ggraph)
# Read in edgelist into data frame
dat <- read_csv("Catalog_SiteA.csv",
col_select = c(LEVEL_ID, CODE))
# Create graph
g_assemblages_bpg <-
graph_from_data_frame(unique.data.frame(dat),
directed = FALSE)
# Assign bipartite node types
V(g_assemblages_bpg)$type <-
bipartite_mapping(g_assemblages_bpg)$type
#| fig-width: 8
#| fig-cap: "Bipartite graph of artifact-provenience connections."
# Plot bipartite graph
g_assemblages_bpg %>%
ggraph(layout = "bipartite") +
geom_edge_link(color = "gray", alpha = 0.25) +
geom_node_point(aes(color = type), size = 2) +
scale_color_manual(
values = c("green", "blue"),
name = "Node Type",
breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")) +
ggtitle("Bipartite network of Provenience and Artifact Type")
g_assemblages_bpg_inc <- as_incidence_matrix(g_assemblages_bpg)
# View the first few rows and columns
g_assemblages_bpg_inc[1:5, 1:15]
# Szymkiewicz-Simpson overlap coefficient for binary incidence matrices
overlap_coef_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Find the smaller of each pair of sets by taking the matrix outer minimum
min_set_size_mat <- outer(col_sum, col_sum, FUN = pmin)
# Szymkiewicz-Simpson overlap coefficient is the pairwise intersection of two
# sets divided by the size of the smaller set
ssoc <- bin_intersect_mat / min_set_size_mat
# Set diagonal to identity
diag(ssoc) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(ssoc) <- list(colnames(x), colnames(x))
return(ssoc)
}
# Jaccard/Tanimoto similarity index for binary incidence matrices
jaccard_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
x_col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(x_col_sum, x_col_sum, FUN = "+")
# Jaccard index is intersection of set sizes over the size of the union of
# sets
jacc <- bin_intersect_mat / (set_size_sum_mat - bin_intersect_mat)
# Set diagonal to identity
diag(jacc) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(jacc) <- list(colnames(x), colnames(x))
return(jacc)
}
# Sørensen–Dice Coefficient for binary incidence matrices
soren_dice_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums, to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(col_sum, col_sum, FUN = "+")
# Sorenson-Dice index is twice the size of the intersection divided by the
# sum of the size for each set
sd <- (2 * bin_intersect_mat) / set_size_sum_mat
# Set diagonal to identity
diag(sd) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(sd) <- list(colnames(x), colnames(x))
return(sd)
}
#| fig-cap: "Sample size distributions for provenience and artifact types."
require(gridExtra)
grid.arrange(
ggplot(
data = data.frame(x = rowSums(g_assemblages_bpg_inc)),
aes(x = x)) +
geom_histogram(color = "gray", fill = "green", bins = 20) +
ggtitle("Artifact Types per Provenience"),
ggplot(
data = data.frame(x = colSums(g_assemblages_bpg_inc)),
aes(x = x)) +
geom_histogram(color = "gray", fill = "blue", bins = 20) +
ggtitle("Occurence per Artifact Type"),
ncol = 2
)
# Overlap coefficient, provenience
prov_adj_ssoc <- overlap_coef_bin(t(g_assemblages_bpg_inc))
prov_ssoc_vals <-
prov_adj_ssoc[lower.tri(prov_adj_ssoc, diag = FALSE)]
# Jaccard, provenience
prov_adj_jacc <- jaccard_sim_bin(t(g_assemblages_bpg_inc))
prov_jacc_vals <-
prov_adj_jacc[lower.tri(prov_adj_jacc, diag = FALSE)]
# Sorenson-Dice
prov_adj_sd <- soren_dice_sim_bin(t(g_assemblages_bpg_inc))
prov_sd_vals <-
prov_adj_sd[lower.tri(prov_adj_sd, diag = FALSE)]
# Make data frame to compare
prov_sims <-
data.frame(ssoc = prov_ssoc_vals,
jacc = prov_jacc_vals,
sd = prov_sd_vals)
# Plot densities by similarity measure
prov_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "green",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
# Overlap coefficient, artifact types
artifact_adj_ssoc <- overlap_coef_bin(g_assemblages_bpg_inc)
artifact_ssoc_vals <-
artifact_adj_ssoc[lower.tri(artifact_adj_ssoc, diag = FALSE)]
# Jaccard, artifact types
artifact_adj_jacc <- jaccard_sim_bin(g_assemblages_bpg_inc)
artifact_jacc_vals <-
artifact_adj_jacc[lower.tri(artifact_adj_jacc, diag = FALSE)]
#Sorenson-Dice, artifact types
artifact_adj_sd <- soren_dice_sim_bin(g_assemblages_bpg_inc)
artifact_sd_vals <-
artifact_adj_sd[lower.tri(artifact_adj_sd, diag = FALSE)]
# Make data frame to compare
artifact_sims <-
data.frame(ssoc = artifact_ssoc_vals,
jacc = artifact_jacc_vals,
sd = artifact_sd_vals)
# Plot densities by similarity measure
artifact_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
# Plot densities by similarity measure, excluding zeroes
artifact_sims %>% stack() %>%
filter(values > 0) %>% # Exclude zeroes
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
pwd
require(tidyverse)
require(igraph)
require(ggraph)
# Read in edgelist into data frame
dat <- read_csv("Catalog_SiteA.csv",
col_select = c(LEVEL_ID, CODE))
# Create graph
g_assemblages_bpg <-
graph_from_data_frame(unique.data.frame(dat),
directed = FALSE)
# Assign bipartite node types
V(g_assemblages_bpg)$type <-
bipartite_mapping(g_assemblages_bpg)$type
#| fig-width: 8
#| fig-cap: "Bipartite graph of artifact-provenience connections."
# Plot bipartite graph
g_assemblages_bpg %>%
ggraph(layout = "bipartite") +
geom_edge_link(color = "gray", alpha = 0.25) +
geom_node_point(aes(color = type), size = 2) +
scale_color_manual(
values = c("green", "blue"),
name = "Node Type",
breaks = c(FALSE, TRUE),
labels = c("Provenience", "Artifact")) +
ggtitle("Bipartite network of Provenience and Artifact Type")
g_assemblages_bpg_inc <- as_incidence_matrix(g_assemblages_bpg)
# View the first few rows and columns
g_assemblages_bpg_inc[1:5, 1:15]
# Szymkiewicz-Simpson overlap coefficient for binary incidence matrices
overlap_coef_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Find the smaller of each pair of sets by taking the matrix outer minimum
min_set_size_mat <- outer(col_sum, col_sum, FUN = pmin)
# Szymkiewicz-Simpson overlap coefficient is the pairwise intersection of two
# sets divided by the size of the smaller set
ssoc <- bin_intersect_mat / min_set_size_mat
# Set diagonal to identity
diag(ssoc) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(ssoc) <- list(colnames(x), colnames(x))
return(ssoc)
}
# Jaccard/Tanimoto similarity index for binary incidence matrices
jaccard_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums to find the individual size of each set
x_col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(x_col_sum, x_col_sum, FUN = "+")
# Jaccard index is intersection of set sizes over the size of the union of
# sets
jacc <- bin_intersect_mat / (set_size_sum_mat - bin_intersect_mat)
# Set diagonal to identity
diag(jacc) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(jacc) <- list(colnames(x), colnames(x))
return(jacc)
}
# Sørensen–Dice Coefficient for binary incidence matrices
soren_dice_sim_bin <- function(x) {
# Calculate the pairwise sums of non-zero matrix elements to find the number
# of intersecting elements between each input column
bin_intersect_mat <- t(x) %*% x
# Calculate the input column sums, to find the individual size of each set
col_sum <- apply(x, 2, function(xx)
sum(xx != 0))
# Calculate the matrix outer sums for pairwise sum of set sizes
set_size_sum_mat <- outer(col_sum, col_sum, FUN = "+")
# Sorenson-Dice index is twice the size of the intersection divided by the
# sum of the size for each set
sd <- (2 * bin_intersect_mat) / set_size_sum_mat
# Set diagonal to identity
diag(sd) <- 1
# Assign input column names to rows and columns of return matrix
dimnames(sd) <- list(colnames(x), colnames(x))
return(sd)
}
#| fig-cap: "Sample size distributions for provenience and artifact types."
require(gridExtra)
grid.arrange(
ggplot(
data = data.frame(x = rowSums(g_assemblages_bpg_inc)),
aes(x = x)) +
geom_histogram(color = "gray", fill = "green", bins = 20) +
ggtitle("Artifact Types per Provenience"),
ggplot(
data = data.frame(x = colSums(g_assemblages_bpg_inc)),
aes(x = x)) +
geom_histogram(color = "gray", fill = "blue", bins = 20) +
ggtitle("Occurence per Artifact Type"),
ncol = 2
)
# Overlap coefficient, provenience
prov_adj_ssoc <- overlap_coef_bin(t(g_assemblages_bpg_inc))
prov_ssoc_vals <-
prov_adj_ssoc[lower.tri(prov_adj_ssoc, diag = FALSE)]
# Jaccard, provenience
prov_adj_jacc <- jaccard_sim_bin(t(g_assemblages_bpg_inc))
prov_jacc_vals <-
prov_adj_jacc[lower.tri(prov_adj_jacc, diag = FALSE)]
# Sorenson-Dice
prov_adj_sd <- soren_dice_sim_bin(t(g_assemblages_bpg_inc))
prov_sd_vals <-
prov_adj_sd[lower.tri(prov_adj_sd, diag = FALSE)]
# Make data frame to compare
prov_sims <-
data.frame(ssoc = prov_ssoc_vals,
jacc = prov_jacc_vals,
sd = prov_sd_vals)
# Plot densities by similarity measure
prov_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "green",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
# Overlap coefficient, artifact types
artifact_adj_ssoc <- overlap_coef_bin(g_assemblages_bpg_inc)
artifact_ssoc_vals <-
artifact_adj_ssoc[lower.tri(artifact_adj_ssoc, diag = FALSE)]
# Jaccard, artifact types
artifact_adj_jacc <- jaccard_sim_bin(g_assemblages_bpg_inc)
artifact_jacc_vals <-
artifact_adj_jacc[lower.tri(artifact_adj_jacc, diag = FALSE)]
#Sorenson-Dice, artifact types
artifact_adj_sd <- soren_dice_sim_bin(g_assemblages_bpg_inc)
artifact_sd_vals <-
artifact_adj_sd[lower.tri(artifact_adj_sd, diag = FALSE)]
# Make data frame to compare
artifact_sims <-
data.frame(ssoc = artifact_ssoc_vals,
jacc = artifact_jacc_vals,
sd = artifact_sd_vals)
# Plot densities by similarity measure
artifact_sims %>% stack() %>%
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
# Plot densities by similarity measure, excluding zeroes
artifact_sims %>% stack() %>%
filter(values > 0) %>% # Exclude zeroes
ggplot(aes(x = values)) +
geom_density(color = "blue",
alpha = 0.4) +
facet_grid(ind ~ ., scales = "free")
