<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.247">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="James Scott Cardinal">
<meta name="dcterms.date" content="2023-04-19">

<title>From similarity to network: Building graphs for community detection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">From similarity to network: Building graphs for community detection</h1>
<p class="subtitle lead">Data Science in Archaeology, Part III.a.</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>James Scott Cardinal </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 19, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="archaeo_DS_mine.png" class="img-fluid figure-img" alt="Archaeology and Data Science"></p>
<p></p><figcaption class="figure-caption">Why is there math in my archaeology? …or is the archaeology in my math? (Image by Author)</figcaption><p></p>
</figure>
</div>
<p>It has been a little while since my last installment (<a href="https://towardsdatascience.com/similarity-measures-and-graph-adjacency-with-sets-a33d16e527e1" title="Similarity Measures and Graph Adjacency with Sets">Part II</a>). End of year projects, deadlines, and (of course) the holidays kept me overly busy. My thanks for your patience, and I’ll try and make it worth the wait.</p>
<p>Last time, we talked about different similarity metrics for sets or combinatorial problems, and the particular strengths and idiosyncrasies of each. We were trying to find the best way to project our bipartite graph of archaeological proveniences and artifacts into individual one-mode graphs. Our goal is to find communities in each of those projected graphs to find meaningful <em>assemblages</em> (communities of artifacts) and <em>contexts</em> (communities of provenience locations).</p>
<p>That does, however, require that we talk about how we determine “best” for this particular scenario. Since our goal is community detection, we want to choose the metric that connects vertices that have the strongest associations while <em>avoiding</em> spurious or non-informative edges. I mentioned last time that we are, in part, looking to see if our projected graphs exhibit characteristics of a <em>scale-free</em> network. We’ll talk about that more later in this post, but it boils down to finding a network where most nodes have a few strong connections rather than a lot of weak ones.</p>
<p>Since this is likely to be a fairly large and involved topic, I’m breaking Part III into two posts. This one (Part III.a.) will talk about translating our similarity measures into a network, and building the graphs. The next one (Part III.b.) will tackle the community detection methods, of which there are many.</p>
<p>For those just joining in, this is the third installment of a series on archaeological data science covering:</p>
<ul>
<li><p><a href="https://medium.com/p/648a2f20d389" title="Bipartite Graphs for Archaeological Assemblage Networks">Part I</a> – Creating and exploring bipartite and one-mode graphs,</p></li>
<li><p><a href="https://towardsdatascience.com/similarity-measures-and-graph-adjacency-with-sets-a33d16e527e1" title="Similarity Measures and Graph Adjacency with Sets">Part II</a> – Similarity measures for sets and graph adjacency,</p></li>
<li><p>Part III – Graph structure and community detection methods,</p>
<ul>
<li><p>a.) Scale-free and small world networks</p></li>
<li><p>b.) Community detection methods</p></li>
</ul></li>
<li><p>Part IV – Geo-spatial networks</p></li>
</ul>
<p>I’ll continue using R for the <a href="https://github.com/archaeojsc/assemblage_network" title="Assemblage Network GitHub">coding</a>, but all of this could be done with Python just as easily.</p>
<section id="sec-introduction" class="level2">
<h2 class="anchored" data-anchor-id="sec-introduction">Introduction</h2>
<p>In <a href="https://towardsdatascience.com/similarity-measures-and-graph-adjacency-with-sets-a33d16e527e1" title="Similarity Measures and Graph Adjacency with Sets">Part II</a>, we went into some depth about what it means for sets to be <em>similar</em> and some ways to calculate a metric for that similarity. This time around, we’re going to look more closely into how to decide what it means to be similar <em>enough</em>. In other words, we want to find an analytically valid way to decide on a <em>threshold</em> of similarity that best captures the real connections between entities while avoiding spurious associations. That will also help to guide us in selecting which of the similarity metrics to use (i.e., overlap, Jaccard, or Sørensen–Dice) as we go on to start building our bipartite graph projections.</p>
<section id="sec-a-quick-recap..." class="level3">
<h3 class="anchored" data-anchor-id="sec-a-quick-recap...">A quick recap…</h3>
<p>We started (in <a href="https://medium.com/p/648a2f20d389" title="Bipartite Graphs for Archaeological Assemblage Networks">Part I</a>) by building a bipartite graph between artifact types and their locations, shown in <a href="#fig-bipartite-graph">Figure&nbsp;1</a>. To keep things simple, we’re using an <em>un-</em>weighted bipartite graph to look at co-locations of artifact types.</p>
<div class="cell">

</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-bipartite-graph" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-bipartite-graph-1.png" class="img-fluid figure-img" alt="Bipartite graph plot of proveniences and artifact types." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: Bipartite network of Provenience and Artifact Type.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Looking at the bipartite graph, it seems apparent that there are some natural clusters or groupings. We found, though, that projecting this graph into its one-mode counterparts resulted in very densely connected networks.</p>
<p>Next, in <a href="https://towardsdatascience.com/similarity-measures-and-graph-adjacency-with-sets-a33d16e527e1" title="Similarity Measures and Graph Adjacency with Sets">Part II</a>, we looked at different similarity metrics to find a better method of projection that the simple overlap provided in <code>igraph</code>. We looked at the similarities calculated with the Szymkiewicz-Simpson overlap coefficient, Jaccard similarity coefficient, and Sørensen–Dice coefficient for both provenience (<a href="#fig-sim-prov">Figure&nbsp;2</a>) and artifact types (<a href="#fig-sim-artifact">Figure&nbsp;3</a>).</p>
<div class="cell">

</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-sim-prov" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-sim-prov-1.png" class="img-fluid figure-img" alt="Similarity measures for proveniences." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;2: Similarity measures for proveniences.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>For proveniences, it looks like there are quite a few that have in their artifact content. Looking at the density of scores for each methods, it appears that in fact the <em>majority</em> of proveniences have non-zero similarity scores. There are discernible “peaks” at zero and, for Jaccard and Sørensen-Dice at least, most scores are below <span class="math inline">\(0.5\)</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-sim-artifact" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-sim-artifact-1.png" class="img-fluid figure-img" alt="Similarity measures for artifact types." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;3: Similarity measures for artifact types.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Unlike the proveniences, the co-location of artifacts is obviously much more sparse and the density plot is dominated by the left-hand “spike” of zero similarities. Looking closely, though, we can notice some apparent “bumps” along the right tails (most obvious for the overlap coefficient) where we seem to have a fair number of higher similarity artifacts. In other words, some artifact types occur together quite often.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-sim-artifact-nonzero" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-sim-artifact-nonzero-1.png" class="img-fluid figure-img" alt="Non-zero similarity measures for artifact types." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4: Non-zero similarity measures for artifact types.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Filtering the artifact similarities to only display non-zero values, we an see the distribution of similarities a little better within that right tail. Sørensen–Dice and Jaccard scores still concentrate on the lower end of the scale, while it’s apparent that the overlap coefficient is rating the similarities considerably higher.</p>
<p>If you remember from the last installment, the overlap coefficient captures subsets and has a more “permissive” approach to scoring similarities. Sørensen–Dice and Jaccard, however, penalize differences in their scoring, which lead to lower overall similarity scores</p>
<p>Now what we want to do is look at how to go about selecting our similarity metric, how to find appropriate thresholds of similarity, and what effects these have on the resulting graph projections. The goal is to find the right metric and threshold that will allow us to detect the underlying structure of the relationships within and between proveniences and artifact types.</p>
</section>
</section>
<section id="sec-graph-structure-and-scale-free-networks" class="level2">
<h2 class="anchored" data-anchor-id="sec-graph-structure-and-scale-free-networks">Graph structure and scale-free networks</h2>
<p>What we’re trying to do is find out if the inherent structure of our projected graphs, and therefore our bipartite graph as a whole, shows whether or not it is <em>random</em>. If the structure does <em>not</em> appear to be random, then we can reasonably infer that some other process is constraining or directing which artifacts appear where. In archaeological terms, that means that it’s likely that there is some intentional organization to the use of space for certain activities or that certain artifact assemblages are associated with different activities. If so, then we can find some partitioning of the artifacts and/or proveniences that have meaningful interpretations.</p>
<p>Mind you, we’re not actually trying to <em>induce</em> a structure. We are, however, expecting that there has been some manner of degradation in the “signal” of our data (see the introduction to <a href="https://medium.com/p/648a2f20d389" title="Bipartite Graphs for Archaeological Assemblage Networks">Part I</a> as to why). Our selection of similarity and threshold are meant to dampen the “noise” introduced to the site over time.</p>
<p>One way to determine if we have non-random structure in our graph is to find out if it exhibits <a href="https://en.wikipedia.org/wiki/Scale-free_network" title="Scale-free network | WikipediA"><em>scale-free network</em></a> properties. A scale-free network is one in which the distribution for the degree of nodes in the graph approximate a power-law distribution, meaning that most nodes in the graphs have few connections while a few “hub” nodes have many. In a random network, there would be a more <em>even</em>ly distributed probability of node degrees and hub nodes would be far less likely to occur.</p>
<p>The presence of a scale-free network suggests that there is some latent <em>non</em>-random process at play that is driving differential attachments between those nodes. It may be that there is a different process of growth in the network, which archaeologically would be some different spatial or temporal process of artifact deposition. Alternatively, there may be a clustering process or preferential attachment by which certain nodes are more closely associated than others as in the case of hub nodes. A certain suite of artifacts that are all related to the same activities (i.e., an <em>assemblage</em>) would cluster together, for example.</p>
<section id="sec-detecting-scale-free-networks" class="level3">
<h3 class="anchored" data-anchor-id="sec-detecting-scale-free-networks">Detecting scale-free networks</h3>
<p>If a network is scale-free, then the distribution of node degree will approximate a power-law distribution of the form <span class="math inline">\(P_{\text{deg}}(k) \propto k^{-\gamma}\)</span> where <span class="math inline">\(k\)</span> is node degree and <span class="math inline">\(\gamma\)</span> is some exponent. We will know <span class="math inline">\(k\)</span>, but we would obviously need to find the appropriate value for <span class="math inline">\(\gamma\)</span> from our empirical distribution. To illustrate, lets look at the probability density function for various values of <span class="math inline">\(\gamma\)</span> (<a href="#fig-power-law">Figure&nbsp;5</a>). We have 251 artifact types in our archaeological sample data, so lets look at the ideal power-law distributions if each node could have a maximum of 251 degrees.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-power-law" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-power-law-1.png" class="img-fluid figure-img" alt="Power-law distribution for different values of gamma." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;5: Power-law distribution for different values of gamma.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Pretty easy to see that if our artifact type graph were scale free, the vast majority of the nodes would have a <em>very</em> small degree. Not so easy to see how much that probability is affected by <span class="math inline">\(\gamma\)</span>, though. It’s a lot easier to see the effect of <span class="math inline">\(\gamma\)</span> if we take the <span class="math inline">\(\log\)</span> of <span class="math inline">\(P_{\text{deg}}(k)\)</span> (<a href="#fig-power-law-log">Figure&nbsp;6</a>).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-power-law-log" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-power-law-log-1.png" class="img-fluid figure-img" alt="Log-scale power-law distribution for different values of gamma." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;6: Log-scale power-law distribution for different values of gamma.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>For every increment of the exponent <span class="math inline">\(\gamma\)</span>, the probability of higher-degree nodes decreases much more quickly. This will help in selecting our similarity metric, when we look at which one produces a graph network that approximates this sort of power-law in its degree distribution.</p>
</section>
<section id="sec-why-a-scale-free-network" class="level3">
<h3 class="anchored" data-anchor-id="sec-why-a-scale-free-network">Why a scale-free network?</h3>
<p>This is, of course, not the only way to look for non-random structure in a graph network. It’s reasonable, then, to be wondering why we would expect our archaeological networks should follow this sort of power-law structure. This subject could easily be its own article, to be honest, but the short-form version is that it’s because there is a natural connection between information entropy, power-law distributions, and the information communicated about an archaeological site by individual artifact types.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> The artifact types found on a site communicate information about the activities that occurred there, and the provenience (i.e., location) of those types tell us about the spatial organization of those activities.</p>
<p>There are, actually, some surprising similarities with how different gene expressions correlate with phenotype. If you think about the co-location of artifact types being something like genetic expressions and a provenience being the individual sample, then the correspondence of artifact “expressions” between samples should indicate that they’re from the same “population” of characteristics (i.e., phenotype). The methods being presented in this series of articles originated with my experiments in adapting <a href="https://en.wikipedia.org/wiki/Weighted_correlation_network_analysis" title="Weighted correlation network analysis">weighted gene co-expression network analysis</a> to archaeological data.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Scale-free network construction is one of the crucial steps in those methods.</p>
<p>The biggest difference between the genetic applications, and what we’re doing here archaeologically, is that we’re aiming to do this along each dimension of the problem. We’re first looking to see if there are groups of artifact types (i.e., assemblages) that are separable and reflect either different activities (e.g., domestic versus architectural artifacts) or different temporal occupations (e.g., 18th century versus 19th century). <em>Then</em> we’re going to go back and see of those assemblages are separated spatially by groups of proveniences (i.e., contexts).</p>
<p>It’s a bi-clustering problem in some ways, but we have to first identify rough clusters <em>within</em> the locations or artifacts.</p>
</section>
</section>
<section id="sec-from-similarity-to-adjacency" class="level2">
<h2 class="anchored" data-anchor-id="sec-from-similarity-to-adjacency">From similarity to adjacency</h2>
<p>We could simply use our raw similarity scores to build our networks, but we would still have very dense and noisy graphs. Instead, we want to find a method that boosts the <em>signal</em> of our graph structure, while suppressing the <em>noise</em> from spurious associations. To do that, we need to filter our similarity scores to form a graph adjacency matrix containing (as much as possible) only the most significant associations between entities. There are essentially two ways we can go about this.</p>
<p>The simplest is to just set a hard cutoff threshold – e.g., a specific value or quantile – and build an un-weighted or binary adjacency matrix. If we select the right threshold, this can be very effective and results in a more sparse graph. The downside is that it risks discarding legitimate (albeit lower strength) connections along with the noise, and tends to leave isolated nodes (i.e., nodes that aren’t connected to any others).</p>
<p>Another approach is to use a function to calculate a <em>soft</em> threshold value, along the lines of an activation function. This results in a weighted graph in which smaller similarity values are pushed closer towards zero, while very high similarity values would stay closer to one. The advantage is that there is less risk of suppressing significant connections. The downside is that the noise is still in there, albeit substantially dampened, and doesn’t decrease the graph’s overall density. Weighted graphs are also just a bit more complicated to parse for community detection. Some methods consider edge weight as strength of connection, while others require the edge weights to be a measure of distance between nodes.</p>
<p>Thankfully, the two are not mutually exclusive! A hybrid approach would be to boost the similarity signal by employing a soft threshold function, and <em>then</em> finding an appropriate hard threshold. This is, in effect, what ultimately happens when you apply a clustering algorithm to a distance matrix. Whether it’s selecting the number of clusters or setting a cutoff distance to a dendrogram, you’re essentially deciding membership by picking a hard threshold to the measure being evaluated.</p>
<p>Graph community detection is quite closely related to non-graph clustering, particularly hierarchical clustering. Setting a threshold for building the adjacency matrix determines the resulting structure of the graph.</p>
<section id="sec-hard-thresholds" class="level3">
<h3 class="anchored" data-anchor-id="sec-hard-thresholds">Hard thresholds</h3>
<p>A hard threshold is the simplest to implement – any similarity value lower than your threshold goes to zero, and equal or higher goes to one. The trick is in picking that value, which we’ll explore a little later, but you can think of it as tuning a model parameter. The objective would be to maximize the strength of connections, minimize node degree, and avoid isolates.</p>
<p>So, lets formally define our hard threshold adjacency matrix<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> as <span class="math inline">\(A_{i,j}\)</span> , our similarity matrix as <span class="math inline">\(S_{i,j}\)</span>, and our threshold value as <span class="math inline">\(\tau\)</span>.</p>
<p><span id="eq-signum-adj"><span class="math display">\[
A_{i,j} = f(S_{i,j}, \tau) \equiv
\begin{cases}
0 &amp; \text{if } S_{i,j} &lt; \tau\\
1 &amp; \text{if } S_{i,j} \geq \tau
\end{cases}
\tag{1}\]</span></span></p>
<p>We can easily code that up as a function <code>hard_threshold_adj</code>, which takes a similarity matrix <code>sim_mat</code> and a threshold value <code>tau</code> as arguments and returns a binary adjacency matrix.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>hard_threshold_adjacency <span class="ot">&lt;-</span> <span class="cf">function</span>(sim_mat, tau) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">ifelse</span>(sim_mat <span class="sc">&lt;</span> tau, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="sec-soft-thresholds" class="level3">
<h3 class="anchored" data-anchor-id="sec-soft-thresholds">Soft thresholds</h3>
<p>Soft thresholds consist of a transformation of the raw similarity score by passing it through a function that boosts stronger similarities and suppresses weaker ones. Those familiar with activation functions in deep learning will already be accustomed to the variety of approaches available – e.g., sigmoid function, tangent hyperbolic or “tanh” function, etc. Soft thresholds work the same way, transforming the input values into a monotonically increasing output value.</p>
<p>Soft thresholds result in weighted graphs, therefore they do not reduce the graph’s density or alter the degree distribution, unless a subsequent (hard) threshold is applied as well. In a weighted network, though, the density is less of an issue, since all metrics become proportional to the associated edge weights. It does, however, become rather more computationally intensive. The advantage of that trade-off is that more of the information about the relationships is retained in the graph’s structure.</p>
<p>Since our similarity scores are already in the range <span class="math inline">\([0,1]\)</span>, we don’t really need quite the same sort transformation as we would if we needed to take any real number as an input. We just need to “bend” our linear input range to minimize some portion of the smaller values. Luckily, there is a very simple way to do that by using an exponential function. We’ll define a power adjacency<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> function:</p>
<p><span id="eq-power-adj"><span class="math display">\[
Power(S_{i,j}) = |S_{i,j}|^{\beta}
\tag{2}\]</span></span></p>
<p>This is simply raising the absolute value of our raw input value to some power <span class="math inline">\(\beta\)</span>. Our similarity scores are all <span class="math inline">\([0,1]\)</span> so the absolute value is irrelevant in this case. For other use cases, it would be necessary.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>power_adj <span class="ot">&lt;-</span> <span class="cf">function</span>(x, beta) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span>(x) <span class="sc">^</span> beta</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Increasing <span class="math inline">\(\beta\)</span> can be seen to push the smaller values towards zero, which increases the minimum value at which the adjacency score exceeds <span class="math inline">\(0.5\)</span> (thus, it’s a <em>soft</em> threshold). For example, at <span class="math inline">\(\beta=2\)</span> only similarity values of <span class="math inline">\(S_{i,j} \geq 0.71\)</span> would break the <span class="math inline">\(0.5\)</span> adjacency threshold and the weights of all lower values penalized. At <span class="math inline">\(\beta=3\)</span> it would take <span class="math inline">\(S_{i,j} \geq 0.79\)</span> and so on.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-power-adjacency" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="assemblage_network_doc_3_building_files/figure-html/fig-power-adjacency-1.png" class="img-fluid figure-img" alt="Power adjacency distribution for different values of beta." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;7: Power adjacency distribution for different values of beta.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-choosing-threshold-type-and-parameters" class="level2">
<h2 class="anchored" data-anchor-id="sec-choosing-threshold-type-and-parameters">Choosing threshold type and parameters</h2>
<p>So, now that we’ve explored some similarity and adjacency methods, the question remains – how do we choose between them? We’re looking for non-random structure within our sample data, and we know that the non-random distribution of connections in our network <em>should</em> approximate a scale-free network. Therefore, we want to pick the similarity measure and adjacency threshold that result in a graph that best approximates such a network.</p>
<p>How do we do that?</p>
<p>Well, one proven method<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> is that we can test the fit of a linear regression between the the observed distribution of network connectivity and an ideal power law probability distribution. The higher the <span class="math inline">\(R^2\)</span> of the model fit, the closer the observed data is to a scale-free topology.</p>
<p>It’s important to note that the meaning of “connectivity” is different for weighted (soft) and un-weighted (hard) adjacency. For un-weighted graphs, connectivity is simply the degree of each node. If the edges are weighted, though, connectivity is the sum of edge weights (or “strength”) connected to each node.</p>
<p>Our next step, then, is to evaluate each of our similarity matrices to see which one most closely fits to a scale-free network. Before we do that, though, let’s take a look at what the connectivity look like when just using the similarity scores as the network adjacency.</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-Justeson1973" class="csl-entry" role="doc-biblioentry">
Justeson, John S. 1973. <span>“Limitations of Archaeological Inference: An Information-Theoretic Approach with Applications in Methodology.”</span> <em>American Antiquity</em> 38 (April): 131–49. <a href="https://doi.org/10.2307/279360">https://doi.org/10.2307/279360</a>.
</div>
<div id="ref-Langfelder2008b" class="csl-entry" role="doc-biblioentry">
Langfelder, Peter, and Steve Horvath. 2008. <span>“WGCNA: An r Package for Weighted Correlation Network Analysis.”</span> <em>BMC Bioinformatics</em> 9: 559. <a href="https://doi.org/10.1186/1471-2105-9-559">https://doi.org/10.1186/1471-2105-9-559</a>.
</div>
<div id="ref-Zhang2005" class="csl-entry" role="doc-biblioentry">
Zhang, Bin, and Steve Horvath. 2005. <span>“A General Framework for Weighted Gene Co-Expression Network Analysis.”</span> <em>Statistical Applications in Genetics and Molecular Biology</em> 4 (January): Article17. <a href="https://doi.org/10.2202/1544-6115.1128">https://doi.org/10.2202/1544-6115.1128</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>See <span class="citation" data-cites="Justeson1973">Justeson (<a href="#ref-Justeson1973" role="doc-biblioref">1973</a>)</span> for a detailed explanation.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>For more information about weighted gene co-expression network analysis and scale free networks, see <span class="citation" data-cites="Zhang2005">Zhang and Horvath (<a href="#ref-Zhang2005" role="doc-biblioref">2005</a>)</span> and <span class="citation" data-cites="Langfelder2008b">Langfelder and Horvath (<a href="#ref-Langfelder2008b" role="doc-biblioref">2008</a>)</span><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Adapted from <span class="citation" data-cites="Zhang2005">Zhang and Horvath (<a href="#ref-Zhang2005" role="doc-biblioref">2005</a>)</span><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Again, we’re following after <span class="citation" data-cites="Zhang2005">Zhang and Horvath (<a href="#ref-Zhang2005" role="doc-biblioref">2005</a>)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>For example, if we were including multiplicities of events (i.e., how <em>many</em> of each artifact type was found at each location), then different similarity measures or correlations would be appropriate that might produced signed values.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>See <span class="citation" data-cites="Zhang2005">Zhang and Horvath (<a href="#ref-Zhang2005" role="doc-biblioref">2005</a>)</span><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>